@file:Suppress("LocalVariableName")

package evo

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import net.hollowcube.luau.LuaFunc
import net.hollowcube.luau.LuaState

class LuauFunctionProcessor(val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor {

    val objectName = "SyntheticLuauLibs"
    val reserved = setOf("ALL")
    val lualayer = "evo.lualayer"

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val luauFunctionAnnotation = resolver.getKSNameFromString("$lualayer.annotations.LuauFunction")
        val annotatedFunctions = resolver.getSymbolsWithAnnotation(luauFunctionAnnotation.asString())
            .filterIsInstance<KSFunctionDeclaration>()

        if (!annotatedFunctions.iterator().hasNext()) {
            return emptyList()
        }

        val generatedClassBuilder = TypeSpec.objectBuilder(objectName).addKdoc("Generated by KSP.")

        val luauLibsMap: MutableMap<String, MutableMap<String, String>> = mutableMapOf()
        val luauLibType = ClassName("$lualayer.wrapper", "LuauLib")

        annotatedFunctions.forEach { function ->
            val annotation = function.annotations.first { it.shortName.asString() == "LuauFunction" }
            val luauFunctionName = annotation.arguments.getString("name")
            val luauLibName = (annotation.arguments.getString("lib") ?: "GLOBAL").uppercase().replace(" ", "_")

            luauLibsMap[luauLibName]?.any { it.key == luauFunctionName }?.let {
                if (it) {
                    logger.error("The function name '$luauFunctionName' already exists in the library '$luauLibName'.", function)
                    return@forEach
                }
            }

            val libraryName = if (luauLibName in reserved) {
                logger.error("The library name '$luauLibName' is reserved and cannot be used.", function)
                return@forEach
            } else {
                luauLibName
            }
            val internalFunctionName = luauFunctionName ?: (function.qualifiedName?.asString() ?: function.simpleName.asString()).replace(".", "_")
            val luaFuncClassName = LuaFunc::class.asClassName()
            val luaStateClassName = LuaState::class.asClassName()

            val lambdaBody = CodeBlock.builder()

            val originalArgs = mutableListOf<String>()

            function.parameters.forEachIndexed { index, param ->
                val paramType = param.type.resolve()
                val paramName = param.name?.asString() ?: "arg$index"

                val luauCheckMethod = when (paramType.declaration.qualifiedName?.asString()) {
                    "kotlin.String"  -> "checkStringArg"
                    "kotlin.Int"     -> "checkIntegerArg"
                    "kotlin.Boolean" -> "checkBooleanArg"
                    "kotlin.Double"  -> "checkNumberArg"
                    "kotlin.Float"   -> "checkNumberArg"
                    "kotlin.Long"    -> "checkNumberArg"// Lua Long precision is shit anyway
                    else -> null
                }

                if (luauCheckMethod != null) {
                    val conversion = when (paramType.declaration.qualifiedName?.asString()) {
                        "kotlin.Float" -> ".toFloat()"
                        "kotlin.Long" -> ".toLong()"
                        else -> ""
                    }
                    lambdaBody.addStatement("val %L = state.%L(%L)%L", paramName, luauCheckMethod, index + 1, conversion)
                    originalArgs.add(paramName)
                } else {
                    logger.error(
                        "Unsupported parameter type '${paramType.declaration.qualifiedName?.asString()}' for LuauFunction '${function.simpleName.asString()}'.",
                        param
                    )
                    return@forEach
                }
            }

            val callArgsString = originalArgs.joinToString()

            val parent = function.parent
            val reference: CodeBlock = when (parent) {
                is KSClassDeclaration -> {
                    val inObj = parent.isCompanionObject || parent.classKind == ClassKind.OBJECT
                    if (!inObj) {
                        logger.info(
                            "Skipping function '${function.simpleName.asString()}' in class (not in companion object).",
                            function
                        )
                        return@forEach
                    }
                    val classHierarchy = generateSequence(parent) {
                        it.parent as? KSClassDeclaration
                    }.toList().reversed()

                    val fullClassName = classHierarchy.joinToString(".") { it.simpleName.asString() }

                    val classType = ClassName(function.packageName.asString(), fullClassName)
                    CodeBlock.of("%T.%L", classType, function.simpleName.asString())
                }

                is KSFile -> {
                    val functionClassName = ClassName(function.packageName.asString(), function.simpleName.asString())
                    CodeBlock.of("%T", functionClassName)
                }

                else -> {
                    logger.error(
                        "Unsupported parent type for LuauFunction '${function.simpleName.asString()}': ${parent?.javaClass?.simpleName}",
                        function
                    )
                    return@forEach
                }
            }

            lambdaBody.addStatement("val result = %L(%L)", reference, callArgsString)

            val returnType = function.returnType?.resolve()
            if (returnType != null && returnType.declaration.qualifiedName?.asString() != "kotlin.Unit") {
                val statement = when (returnType.declaration.qualifiedName?.asString()) {
                    "kotlin.String"                             -> "state.pushString(result)"
                    "kotlin.Int"                                -> "state.pushInteger(result)"
                    "kotlin.Boolean"                            -> "state.pushBoolean(result)"
                    "kotlin.Double", "kotlin.Float", "kotlin.Long"             -> "state.pushNumber(result.toDouble())"
                    else -> {
                        logger.error(
                            "Unsupported return type '${returnType.declaration.qualifiedName?.asString()}' for LuauFunction '${function.simpleName.asString()}'.",
                            function
                        )
                        return@forEach
                    }
                }
                lambdaBody.addStatement(statement)
                lambdaBody.addStatement("return@preallocate 1")
            } else {
                lambdaBody.addStatement("return@preallocate 0")
            }

            val VAR_LUA_FUNC = PropertySpec.builder(
                internalFunctionName, luaFuncClassName
            ).initializer(
                CodeBlock.builder().beginControlFlow("%T.preallocate { state: %T ->", luaFuncClassName, luaStateClassName)
                    .add(lambdaBody.build())
                    .endControlFlow().build()
            ).build()

            generatedClassBuilder.addProperty(VAR_LUA_FUNC)

            luauLibsMap.getOrPut(libraryName) { mutableMapOf() }[luauFunctionName ?: function.simpleName.getShortName()] = internalFunctionName

            logger.info("Generated LuaFunc for: ${function.qualifiedName?.asString()} named '$luauFunctionName'")
        }

        // Lib properties generation

        luauLibsMap.forEach { (libName, funcMapping) ->
            val mapBuilder = CodeBlock.builder().addStatement("mapOf(")
            if (funcMapping.isNotEmpty()) {
                mapBuilder.withIndent {
                    funcMapping.forEach { (luauFunctionName, generatedPropertyName) ->
                        mapBuilder.addStatement("%S to %N,", luauFunctionName, MemberName("", generatedPropertyName))
                    }
                }
            }
            mapBuilder.addStatement("),")

            val libInitializer = CodeBlock.builder()
                .addStatement("%T(", luauLibType)
                .indent()
                .add("%S, ", libName.lowercase())
                .add("%L", mapBuilder.build())
                .addStatement((libName.lowercase() == "global").toString())
                .unindent()
                .addStatement(")")
                .build()

            val VAR_LIB = PropertySpec.builder(
                libName, luauLibType
            ).initializer(libInitializer).build()

            generatedClassBuilder.addProperty(VAR_LIB)
        }

        val VAR_ALL_LIBS = PropertySpec.builder("ALL", SET.parameterizedBy(luauLibType))
            .initializer("setOf(%L)", luauLibsMap.keys.joinToString(", "))
            .build()
        generatedClassBuilder.addProperty(VAR_ALL_LIBS)

        val file = FileSpec.builder("$lualayer.generated", objectName)
            .addAnnotation(
                AnnotationSpec.builder(Suppress::class).addMember("%S", "RedundantVisibilityModifier").build() // Shut up IntelliJ (I can't get rid of public modifiers)
            )
            .indent("    ")
            .addType(generatedClassBuilder.build())
            .build()

        file.writeTo(codeGenerator, false)

        return emptyList()
    }

    class Provider : SymbolProcessorProvider {
        override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
            return LuauFunctionProcessor(environment.codeGenerator, environment.logger)
        }
    }
}

private fun List<KSValueArgument>.getString(arg: String): String? {
    return (firstOrNull { it.name?.asString() == arg }?.value as? String)?.takeIf { it.isNotBlank() }
}
